// File: pkg/utils/printcolor_test.go

package utils

import (
	"bytes"
	"io"
	"os"
	"strings"
	"testing"

	"github.com/fatih/color"
)

/*
init forces color output for tests.
This ensures that the ANSI escape sequences are emitted even if os.Stdout is not a TTY.
*/
func init() {
	color.NoColor = false
}

/*
captureStdout temporarily replaces os.Stdout with a pipe to capture output generated by the provided function.
It returns the captured output as a string.
*/
func captureStdout(f func()) string {
	oldStdout := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w

	f()

	w.Close()
	os.Stdout = oldStdout
	var buf bytes.Buffer
	io.Copy(&buf, r)
	return buf.String()
}

/*
TestPrintColored_SingleString verifies that calling PrintColored with only a single string argument
prints that string in the default white color.
*/
func TestPrintColored_SingleString(t *testing.T) {
	output := captureStdout(func() {
		PrintColored("Just a test string")
	})
	if !strings.Contains(output, "Just a test string") {
		t.Errorf("Expected output to contain %q, got: %q", "Just a test string", output)
	}
	// We expect ANSI codes for white if forced; check that at least one ANSI code is present.
	if !strings.Contains(output, "\x1b[") {
		t.Errorf("Expected output to contain ANSI escape codes for white, got: %q", output)
	}
}

/*
TestPrintColored_TwoStringsWithColor verifies that calling PrintColored with a prefix, a secondary string,
and a color attribute prints the prefix in the specified color and the secondary text in default formatting.
*/
func TestPrintColored_TwoStringsWithColor(t *testing.T) {
	output := captureStdout(func() {
		PrintColored("Prefix: ", "Value", color.FgHiGreen)
	})
	if !strings.Contains(output, "Prefix: ") {
		t.Errorf("Expected output to contain %q, got: %q", "Prefix: ", output)
	}
	if !strings.Contains(output, "Value") {
		t.Errorf("Expected output to contain %q, got: %q", "Value", output)
	}
	// Check for the ANSI escape code for high-intensity green (commonly "\x1b[92m").
	if !strings.Contains(output, "\x1b[92m") {
		t.Errorf("Expected output to contain ANSI code for high-intensity green, got: %q", output)
	}
}

/*
TestPrintColored_DynamicUsage verifies that calling PrintColored with a []string as the first argument
and a []color.Attribute as the second argument results in dynamic multi-segment printing.
It ensures that each text segment is printed with the corresponding color, and if there are more text segments
than colors, the last provided color is used.
*/
func TestPrintColored_DynamicUsage(t *testing.T) {
	texts := []string{"Segment1 ", "Segment2 ", "Segment3"}
	colors := []color.Attribute{color.FgHiGreen, color.FgHiMagenta}
	output := captureStdout(func() {
		PrintColored(texts, colors)
	})

	// Verify that all text segments appear.
	for _, segment := range texts {
		if !strings.Contains(output, segment) {
			t.Errorf("Expected output to contain %q, got: %q", segment, output)
		}
	}
	// Verify that the ANSI codes for high-intensity green and magenta are present.
	if !strings.Contains(output, "\x1b[92m") {
		t.Errorf("Expected output to contain ANSI code for high-intensity green, got: %q", output)
	}
	if !strings.Contains(output, "\x1b[95m") {
		t.Errorf("Expected output to contain ANSI code for high-intensity magenta, got: %q", output)
	}
}

/*
TestPrintColored_MixedArguments verifies that PrintColored can handle mixed argument types.
It tests the function when provided with:
  - A string prefix.
  - A secondary string.
  - A single color attribute.
  - A slice of color attributes.

For the latter case, the function should interpret the slice properly and print using the dynamic printing branch.
*/
func TestPrintColored_MixedArguments(t *testing.T) {
	// Case 1: Using individual arguments.
	output1 := captureStdout(func() {
		PrintColored("Mixed1: ", "Value1", color.FgHiCyan)
	})
	if !strings.Contains(output1, "Mixed1: ") || !strings.Contains(output1, "Value1") {
		t.Errorf("Expected output1 to contain 'Mixed1: ' and 'Value1', got: %q", output1)
	}
	if !strings.Contains(output1, "\x1b[96m") { // ANSI for high-intensity cyan.
		t.Errorf("Expected output1 to contain ANSI code for high-intensity cyan, got: %q", output1)
	}

	// Case 2: Using slices for dynamic printing.
	texts := []string{"Mixed2: ", "Value2"}
	colors := []color.Attribute{color.FgHiYellow, color.FgHiBlue}
	output2 := captureStdout(func() {
		PrintColored(texts, colors)
	})
	if !strings.Contains(output2, "Mixed2: ") || !strings.Contains(output2, "Value2") {
		t.Errorf("Expected output2 to contain 'Mixed2: ' and 'Value2', got: %q", output2)
	}
	if !strings.Contains(output2, "\x1b[93m") { // ANSI for high-intensity yellow.
		t.Errorf("Expected output2 to contain ANSI code for high-intensity yellow, got: %q", output2)
	}
	if !strings.Contains(output2, "\x1b[94m") { // ANSI for high-intensity blue.
		t.Errorf("Expected output2 to contain ANSI code for high-intensity blue, got: %q", output2)
	}
}
