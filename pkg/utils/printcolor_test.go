// File: pkg/utils/printcolor_test.go

package utils

import (
	"bytes"
	"io"
	"os"
	"strings"
	"testing"

	"github.com/fatih/color"
)

/*
init sets the TERM environment variable to force color output during tests.
This ensures that ANSI escape sequences are emitted even in non-TTY environments.
*/
func init() {
	os.Setenv("TERM", "xterm-256color")
	color.NoColor = false
}

/*
captureStdout temporarily replaces os.Stdout with a pipe to capture output generated by the provided function.
It returns the captured output as a string.
*/
func captureStdout(f func()) string {
	oldStdout := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w

	f()

	w.Close()
	os.Stdout = oldStdout
	var buf bytes.Buffer
	io.Copy(&buf, r)
	return buf.String()
}

/*
TestPrintColored_SingleString verifies that calling PrintColored with a single string prints that string in white.
We expect ANSI escape codes to be present due to the forced TERM setting.
*/
func TestPrintColored_SingleString(t *testing.T) {
	output := captureStdout(func() {
		PrintColored("Just a test string")
	})
	if !strings.Contains(output, "Just a test string") {
		t.Errorf("Expected output to contain %q, got: %q", "Just a test string", output)
	}
	// Check that ANSI escape sequences are present.
	if !strings.Contains(output, "\x1b[") {
		t.Errorf("Expected output to contain ANSI escape codes, got: %q", output)
	}
}

/*
TestPrintColored_TwoStringsWithColor verifies that calling PrintColored with a prefix, secondary string, and a color attribute
prints the prefix in the specified color (high-intensity green) and the secondary text in default formatting.
*/
func TestPrintColored_TwoStringsWithColor(t *testing.T) {
	output := captureStdout(func() {
		PrintColored("Prefix: ", "Value", color.FgHiGreen)
	})
	if !strings.Contains(output, "Prefix: ") || !strings.Contains(output, "Value") {
		t.Errorf("Expected output to contain both 'Prefix: ' and 'Value', got: %q", output)
	}
	// Check for ANSI escape code for high-intensity green (usually "\x1b[92m").
	if !strings.Contains(output, "\x1b[92m") {
		t.Errorf("Expected output to contain ANSI code for high-intensity green, got: %q", output)
	}
}

/*
TestPrintColored_DynamicUsage verifies that calling PrintColored with a slice of strings and a slice of colors
results in multi-segment printing. It ensures that each segment is printed in its corresponding color,
and if there are more texts than colors, the last color is used for the remaining segments.
*/
func TestPrintColored_DynamicUsage(t *testing.T) {
	texts := []string{"Segment1 ", "Segment2 ", "Segment3"}
	colors := []color.Attribute{color.FgHiGreen, color.FgHiMagenta}
	output := captureStdout(func() {
		PrintColored(texts, colors)
	})
	for _, segment := range texts {
		if !strings.Contains(output, segment) {
			t.Errorf("Expected output to contain %q, got: %q", segment, output)
		}
	}
	// Check for ANSI codes for high-intensity green and magenta.
	if !strings.Contains(output, "\x1b[92m") {
		t.Errorf("Expected output to contain ANSI code for high-intensity green, got: %q", output)
	}
	if !strings.Contains(output, "\x1b[95m") {
		t.Errorf("Expected output to contain ANSI code for high-intensity magenta, got: %q", output)
	}
}

/*
TestPrintColored_MixedArguments verifies that PrintColored correctly handles mixed argument types.
It tests:
  - Individual string arguments with a single color attribute.
  - Slices of strings with a slice of color attributes.

In both cases, it checks that the output includes the appropriate ANSI escape codes.
*/
func TestPrintColored_MixedArguments(t *testing.T) {
	// Case 1: Individual arguments.
	output1 := captureStdout(func() {
		PrintColored("Mixed1: ", "Value1", color.FgHiCyan)
	})
	if !strings.Contains(output1, "Mixed1: ") || !strings.Contains(output1, "Value1") {
		t.Errorf("Expected output1 to contain 'Mixed1: ' and 'Value1', got: %q", output1)
	}
	if !strings.Contains(output1, "\x1b[96m") { // ANSI for high-intensity cyan.
		t.Errorf("Expected output1 to contain ANSI code for high-intensity cyan, got: %q", output1)
	}

	// Case 2: Using slices for dynamic printing.
	texts := []string{"Mixed2: ", "Value2"}
	colors := []color.Attribute{color.FgHiYellow, color.FgHiBlue}
	output2 := captureStdout(func() {
		PrintColored(texts, colors)
	})
	if !strings.Contains(output2, "Mixed2: ") || !strings.Contains(output2, "Value2") {
		t.Errorf("Expected output2 to contain 'Mixed2: ' and 'Value2', got: %q", output2)
	}
	if !strings.Contains(output2, "\x1b[93m") { // ANSI for high-intensity yellow.
		t.Errorf("Expected output2 to contain ANSI code for high-intensity yellow, got: %q", output2)
	}
	if !strings.Contains(output2, "\x1b[94m") { // ANSI for high-intensity blue.
		t.Errorf("Expected output2 to contain ANSI code for high-intensity blue, got: %q", output2)
	}
}
